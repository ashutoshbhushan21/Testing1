=TRIM(MID(A1, MIN(SEARCH({"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"}, A1&"ABCDEFGHIJKLMNOPQRSTUVWXYZ"), 27), LEN(A1)))


soup = BeautifulSoup(html, 'html.parser')

def find_deepest_tr_with_text(element, target_text):
    result = None
    
    def dfs(current_element, current_depth):
        nonlocal result
        if current_element.name == 'tr' and target_text in current_element.get_text():
            if result is None or current_depth > result[1]:
                result = (current_element, current_depth)
        
        for child in current_element.children:
            if child and child.name:
                dfs(child, current_depth + 1)
    
    dfs(element, 0)
    
    return result[0] if result else None

target_text = "XYZ"
deepest_tr = find_deepest_tr_with_text(soup, target_text)

if deepest_tr:
    print("Deepest <tr> tag containing", target_text, ":", deepest_tr)
else:
    print("No <tr> tag containing", target_text, "found.")







from bs4 import BeautifulSoup, NavigableString

from bs4 import BeautifulSoup, NavigableString

def find_deepest_tag_and_tr_with_text(html, target_text):
    soup = BeautifulSoup(html, 'html.parser')

    deepest_tag_result = None
    deepest_tr_result = None

    def dfs(current_element, current_depth):
        nonlocal deepest_tag_result, deepest_tr_result

        # Check if current element contains target text
        if target_text in current_element.get_text():
            if isinstance(current_element, NavigableString):
                current_tag = current_element.parent
            else:
                current_tag = current_element

            # Update deepest tag if deeper tag is found
            if deepest_tag_result is None or current_depth > deepest_tag_result[1]:
                deepest_tag_result = (current_tag, current_depth)

            # Update deepest tr if deeper tr is found
            tr_ancestor = current_tag.find_parent('tr')
            if tr_ancestor and (deepest_tr_result is None or current_depth > deepest_tr_result[1]):
                deepest_tr_result = (tr_ancestor, current_depth)

        # Proceed only if current element is a tag and can have children
        if hasattr(current_element, 'children'):
            for child in current_element.children:
                if child and hasattr(child, 'name'):
                    dfs(child, current_depth + 1)

    dfs(soup, 0)

    return (deepest_tag_result[0] if deepest_tag_result else None,
            deepest_tr_result[0] if deepest_tr_result else None)

# Example usage
# html_content = "<your_html_content>"
# deepest_tag, deepest_tr = find_deepest_tag_and_tr_with_text(html_content, "XYZ")
# print("Deepest tag containing 'XYZ':", deepest_tag)
# print("Deepest <tr> tag containing a tag with 'XYZ':", deepest_tr)






from bs4 import BeautifulSoup, NavigableString, Tag

def get_soup_between_tags(start_tag, end_tag):
    """
    Creates a BeautifulSoup object containing elements between two specific tags.

    Args:
    start_tag (bs4.element.Tag): The starting tag.
    end_tag (bs4.element.Tag): The ending tag.

    Returns:
    BeautifulSoup: A new soup object containing elements between the start_tag and end_tag.
    """
    elements = []
    current_tag = start_tag

    while current_tag and current_tag != end_tag:
        if isinstance(current_tag, (NavigableString, Tag)):
            elements.append(current_tag)
        current_tag = current_tag.find_next_sibling()

    # Creating a new soup object with the collected elements
    new_soup = BeautifulSoup('', 'html.parser')
    for element in elements:
        new_soup.append(element)

    return new_soup

# Example usage
# html_content = "<your_html_content>"
# soup = BeautifulSoup(html_content, 'html.parser')
# start_tag = <your_method_to_find_start_tag>
# end_tag = <your_method_to_find_end_tag>
# soup_between = get_soup_between_tags(start_tag, end_tag)
# print(soup_between)

