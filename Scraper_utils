=TRIM(MID(A1, MIN(SEARCH({"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"}, A1&"ABCDEFGHIJKLMNOPQRSTUVWXYZ"), 27), LEN(A1)))


soup = BeautifulSoup(html, 'html.parser')

def find_deepest_tr_with_text(element, target_text):
    result = None
    
    def dfs(current_element, current_depth):
        nonlocal result
        if current_element.name == 'tr' and target_text in current_element.get_text():
            if result is None or current_depth > result[1]:
                result = (current_element, current_depth)
        
        for child in current_element.children:
            if child and child.name:
                dfs(child, current_depth + 1)
    
    dfs(element, 0)
    
    return result[0] if result else None

target_text = "XYZ"
deepest_tr = find_deepest_tr_with_text(soup, target_text)

if deepest_tr:
    print("Deepest <tr> tag containing", target_text, ":", deepest_tr)
else:
    print("No <tr> tag containing", target_text, "found.")







from bs4 import BeautifulSoup, NavigableString

from bs4 import BeautifulSoup, NavigableString

def find_deepest_tag_and_tr_with_text(html, target_text):
    soup = BeautifulSoup(html, 'html.parser')

    deepest_tag_result = None
    deepest_tr_result = None

    def dfs(current_element, current_depth):
        nonlocal deepest_tag_result, deepest_tr_result

        # Check if current element contains target text
        if target_text in current_element.get_text():
            if isinstance(current_element, NavigableString):
                current_tag = current_element.parent
            else:
                current_tag = current_element

            # Update deepest tag if deeper tag is found
            if deepest_tag_result is None or current_depth > deepest_tag_result[1]:
                deepest_tag_result = (current_tag, current_depth)

            # Update deepest tr if deeper tr is found
            tr_ancestor = current_tag.find_parent('tr')
            if tr_ancestor and (deepest_tr_result is None or current_depth > deepest_tr_result[1]):
                deepest_tr_result = (tr_ancestor, current_depth)

        # Proceed only if current element is a tag and can have children
        if hasattr(current_element, 'children'):
            for child in current_element.children:
                if child and hasattr(child, 'name'):
                    dfs(child, current_depth + 1)

    dfs(soup, 0)

    return (deepest_tag_result[0] if deepest_tag_result else None,
            deepest_tr_result[0] if deepest_tr_result else None)

# Example usage
# html_content = "<your_html_content>"
# deepest_tag, deepest_tr = find_deepest_tag_and_tr_with_text(html_content, "XYZ")
# print("Deepest tag containing 'XYZ':", deepest_tag)
# print("Deepest <tr> tag containing a tag with 'XYZ':", deepest_tr)






from bs4 import BeautifulSoup, NavigableString, Tag

def get_soup_between_tags(start_tag, end_tag):
    """
    Creates a BeautifulSoup object containing elements between two specific tags.

    Args:
    start_tag (bs4.element.Tag): The starting tag.
    end_tag (bs4.element.Tag): The ending tag.

    Returns:
    BeautifulSoup: A new soup object containing elements between the start_tag and end_tag.
    """
    elements = []
    current_tag = start_tag

    while current_tag and current_tag != end_tag:
        if isinstance(current_tag, (NavigableString, Tag)):
            elements.append(current_tag)
        current_tag = current_tag.find_next_sibling()

    # Creating a new soup object with the collected elements
    new_soup = BeautifulSoup('', 'html.parser')
    for element in elements:
        new_soup.append(element)

    return new_soup

# Example usage
# html_content = "<your_html_content>"
# soup = BeautifulSoup(html_content, 'html.parser')
# start_tag = <your_method_to_find_start_tag>
# end_tag = <your_method_to_find_end_tag>
# soup_between = get_soup_between_tags(start_tag, end_tag)
# print(soup_between)




### to find all deepest td and tr tags

from bs4 import BeautifulSoup, NavigableString, Tag

def dfs_find_deepest_td_and_tr(element, target_text, current_depth, td_records):
    if isinstance(element, NavigableString):
        return
    if element.name == "td" and target_text in element.text:
        tr_parent = element.find_parent('tr')
        td_records.append((current_depth, element, tr_parent))
    for child in element.children:
        if isinstance(child, Tag):
            dfs_find_deepest_td_and_tr(child, target_text, current_depth + 1, td_records)

def find_unique_deepest_td_and_tr(soup, target_text):
    td_records = []
    dfs_find_deepest_td_and_tr(soup, target_text, 0, td_records)

    if not td_records:
        return []

    max_depth = max(record[0] for record in td_records)
    unique_deepest_td_tr = [(td, tr) for depth, td, tr in td_records if depth == max_depth]

    return list(set(unique_deepest_td_tr))  # Remove duplicates if any

# Initialize BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')

# Find all unique deepest 'td' and their 'tr' parents
deepest_td_tr_pairs = find_unique_deepest_td_and_tr(soup, "ABC")

# deepest_td_tr_pairs contains tuples of (td, tr) for each unique deepest 'td' containing 'ABC' and its nearest 'tr' parent






from bs4 import BeautifulSoup, NavigableString, Tag

def find_deepest_tag_with_text(soup, target_text):
    def dfs(element, current_depth, max_depth_info):
        if isinstance(element, NavigableString):
            return
        if target_text in element.get_text():
            if current_depth > max_depth_info["depth"]:
                max_depth_info["depth"] = current_depth
                max_depth_info["element"] = element
        for child in element.children:
            if isinstance(child, Tag):
                dfs(child, current_depth + 1, max_depth_info)

    max_depth_info = {"depth": -1, "element": None}
    dfs(soup, 0, max_depth_info)

    return max_depth_info["element"]

# Example usage
html_doc = """Your HTML content here"""
soup = BeautifulSoup(html_doc, 'html.parser')

deepest_tag = find_deepest_tag_with_text(soup, "ABC")
if deepest_tag:
    print("Deepest tag with 'ABC':", deepest_tag)
else:
    print("No tag with 'ABC' found")


